/*
osap/drivers/step_a4950.cpp

stepper code for two A4950s

Jake Read at the Center for Bits and Atoms
(c) Massachusetts Institute of Technology 2019

This work may be reproduced, modified, distributed, performed, and
displayed for any purpose, but must acknowledge the squidworks and ponyo
projects. Copyright is retained and must be preserved. The work is provided as
is; no warranty is provided, and users accept all liability.
*/

#include "step_a4950.h"
#include "../utils/clamp.h"

// sine, 0-8190, 4095 center / 'zero', 256 steps 
#define LUT_LENGTH 1024 
uint16_t dacLUT[LUT_LENGTH];    // will write 'rectified' LUT here for DAC writing... lazy 
uint16_t LUT_8190[LUT_LENGTH] = {
    4095,4120,4145,4170,4195,4221,4246,4271,4296,4321,4346,4371,4396,4421,4446,4471,
    4496,4521,4546,4571,4596,4621,4646,4671,4696,4721,4746,4770,4795,4820,4845,4869,
    4894,4919,4943,4968,4992,5017,5041,5066,5090,5114,5139,5163,5187,5211,5236,5260,
    5284,5308,5332,5356,5380,5403,5427,5451,5475,5498,5522,5545,5569,5592,5616,5639,
    5662,5685,5708,5731,5754,5777,5800,5823,5846,5869,5891,5914,5936,5959,5981,6003,
    6025,6047,6070,6092,6113,6135,6157,6179,6200,6222,6243,6265,6286,6307,6328,6349,
    6370,6391,6412,6432,6453,6473,6494,6514,6534,6555,6575,6595,6614,6634,6654,6673,
    6693,6712,6731,6751,6770,6789,6808,6826,6845,6864,6882,6900,6919,6937,6955,6973,
    6991,7008,7026,7043,7061,7078,7095,7112,7129,7146,7163,7179,7196,7212,7228,7244,
    7260,7276,7292,7308,7323,7339,7354,7369,7384,7399,7414,7428,7443,7457,7472,7486,
    7500,7514,7528,7541,7555,7568,7581,7594,7607,7620,7633,7646,7658,7670,7683,7695,
    7706,7718,7730,7741,7753,7764,7775,7786,7797,7808,7818,7828,7839,7849,7859,7869,
    7878,7888,7897,7906,7916,7925,7933,7942,7951,7959,7967,7975,7983,7991,7999,8006,
    8014,8021,8028,8035,8042,8048,8055,8061,8067,8073,8079,8085,8091,8096,8101,8106,
    8111,8116,8121,8125,8130,8134,8138,8142,8146,8149,8153,8156,8159,8162,8165,8168,
    8170,8173,8175,8177,8179,8181,8182,8184,8185,8186,8187,8188,8189,8189,8190,8190,
    8190,8190,8190,8189,8189,8188,8187,8186,8185,8184,8182,8181,8179,8177,8175,8173,
    8170,8168,8165,8162,8159,8156,8153,8149,8146,8142,8138,8134,8130,8125,8121,8116,
    8111,8106,8101,8096,8091,8085,8079,8073,8067,8061,8055,8048,8042,8035,8028,8021,
    8014,8006,7999,7991,7983,7975,7967,7959,7951,7942,7933,7925,7916,7906,7897,7888,
    7878,7869,7859,7849,7839,7828,7818,7808,7797,7786,7775,7764,7753,7741,7730,7718,
    7706,7695,7683,7670,7658,7646,7633,7620,7607,7594,7581,7568,7555,7541,7528,7514,
    7500,7486,7472,7457,7443,7428,7414,7399,7384,7369,7354,7339,7323,7308,7292,7276,
    7260,7244,7228,7212,7196,7179,7163,7146,7129,7112,7095,7078,7061,7043,7026,7008,
    6991,6973,6955,6937,6919,6900,6882,6864,6845,6826,6808,6789,6770,6751,6731,6712,
    6693,6673,6654,6634,6614,6595,6575,6555,6534,6514,6494,6473,6453,6432,6412,6391,
    6370,6349,6328,6307,6286,6265,6243,6222,6200,6179,6157,6135,6113,6092,6070,6047,
    6025,6003,5981,5959,5936,5914,5891,5869,5846,5823,5800,5777,5754,5731,5708,5685,
    5662,5639,5616,5592,5569,5545,5522,5498,5475,5451,5427,5403,5380,5356,5332,5308,
    5284,5260,5236,5211,5187,5163,5139,5114,5090,5066,5041,5017,4992,4968,4943,4919,
    4894,4869,4845,4820,4795,4770,4746,4721,4696,4671,4646,4621,4596,4571,4546,4521,
    4496,4471,4446,4421,4396,4371,4346,4321,4296,4271,4246,4221,4195,4170,4145,4120,
    4095,4070,4045,4020,3995,3969,3944,3919,3894,3869,3844,3819,3794,3769,3744,3719,
    3694,3669,3644,3619,3594,3569,3544,3519,3494,3469,3444,3420,3395,3370,3345,3321,
    3296,3271,3247,3222,3198,3173,3149,3124,3100,3076,3051,3027,3003,2979,2954,2930,
    2906,2882,2858,2834,2810,2787,2763,2739,2715,2692,2668,2645,2621,2598,2574,2551,
    2528,2505,2482,2459,2436,2413,2390,2367,2344,2321,2299,2276,2254,2231,2209,2187,
    2165,2143,2120,2098,2077,2055,2033,2011,1990,1968,1947,1925,1904,1883,1862,1841,
    1820,1799,1778,1758,1737,1717,1696,1676,1656,1635,1615,1595,1576,1556,1536,1517,
    1497,1478,1459,1439,1420,1401,1382,1364,1345,1326,1308,1290,1271,1253,1235,1217,
    1199,1182,1164,1147,1129,1112,1095,1078,1061,1044,1027,1011,994,978,962,946,
    930,914,898,882,867,851,836,821,806,791,776,762,747,733,718,704,
    690,676,662,649,635,622,609,596,583,570,557,544,532,520,507,495,
    484,472,460,449,437,426,415,404,393,382,372,362,351,341,331,321,
    312,302,293,284,274,265,257,248,239,231,223,215,207,199,191,184,
    176,169,162,155,148,142,135,129,123,117,111,105,99,94,89,84,
    79,74,69,65,60,56,52,48,44,41,37,34,31,28,25,22,
    20,17,15,13,11,9,8,6,5,4,3,2,1,1,0,0,
    0,0,0,1,1,2,3,4,5,6,8,9,11,13,15,17,
    20,22,25,28,31,34,37,41,44,48,52,56,60,65,69,74,
    79,84,89,94,99,105,111,117,123,129,135,142,148,155,162,169,
    176,184,191,199,207,215,223,231,239,248,257,265,274,284,293,302,
    312,321,331,341,351,362,372,382,393,404,415,426,437,449,460,472,
    484,495,507,520,532,544,557,570,583,596,609,622,635,649,662,676,
    690,704,718,733,747,762,776,791,806,821,836,851,867,882,898,914,
    930,946,962,978,994,1011,1027,1044,1061,1078,1095,1112,1129,1147,1164,1182,
    1199,1217,1235,1253,1271,1290,1308,1326,1345,1364,1382,1401,1420,1439,1459,1478,
    1497,1517,1536,1556,1576,1595,1615,1635,1656,1676,1696,1717,1737,1758,1778,1799,
    1820,1841,1862,1883,1904,1925,1947,1968,1990,2011,2033,2055,2077,2098,2120,2143,
    2165,2187,2209,2231,2254,2276,2299,2321,2344,2367,2390,2413,2436,2459,2482,2505,
    2528,2551,2574,2598,2621,2645,2668,2692,2715,2739,2763,2787,2810,2834,2858,2882,
    2906,2930,2954,2979,3003,3027,3051,3076,3100,3124,3149,3173,3198,3222,3247,3271,
    3296,3321,3345,3370,3395,3420,3444,3469,3494,3519,3544,3569,3594,3619,3644,3669,
    3694,3719,3744,3769,3794,3819,3844,3869,3894,3919,3944,3969,3995,4020,4045,4070
};

STEP_A4950* STEP_A4950::instance = 0;

STEP_A4950* STEP_A4950::getInstance(void){
    if(instance == 0){
        instance = new STEP_A4950();
    }
    return instance;
}

STEP_A4950* step_a4950 = STEP_A4950::getInstance();

STEP_A4950::STEP_A4950() {}

void STEP_A4950::init(boolean invert, float cscale){
    // all of 'em, outputs 
    AIN1_PORT.DIRSET.reg = AIN1_BM;
    AIN2_PORT.DIRSET.reg = AIN2_BM;
    BIN1_PORT.DIRSET.reg = BIN1_BM;
    BIN2_PORT.DIRSET.reg = BIN2_BM;
    // floating cscale 
    clamp(&cscale, 0, 1);
    _cscale = cscale;
    // write a rectified LUT for writing to DACs
    for(uint16_t i = 0; i < LUT_LENGTH; i ++){
        if(LUT_8190[i] > 4095){
            dacLUT[i] = LUT_8190[i] - 4095;
        } else if (LUT_8190[i] < 4095){
            dacLUT[i] = abs(4095 - LUT_8190[i]);
        } else {
            dacLUT[i] = 0;
        }
    }
    // invert direction / not 
    _dir_invert = invert;
    // start the DAAAC
    dacs->init();
    // start condition, 
    writePhases();
}

// do _aStep and _bStep integers, op electronics 
void STEP_A4950::writePhases(void){
    // a phase, 
    if(LUT_8190[_aStep] > 4095){
        A_UP;
    } else if (LUT_8190[_aStep] < 4095){
        A_DOWN;
    } else {
        A_OFF;
    }
    // a DAC 
    dacs->writeDac0(dacLUT[_aStep] * _cscale);

    // b phase, 
    if(LUT_8190[_bStep] > 4095){
        B_UP;
    } else if (LUT_8190[_bStep] < 4095){
        B_DOWN;
    } else {
        B_OFF;
    }
    // b DAC
    dacs->writeDac1(dacLUT[_bStep] * _cscale);
}

// magnetic angle 0-1 maps 0-2PI phase  
// magnitude 0-1 of <range> board's max amp output 
// one complete magnetic period is four 'steps' 
void STEP_A4950::point(float magangle, float magnitude){
    // guard out of range angles & magnitudes 
    clamp(&magangle, 0.0F, 1.0F);
    clamp(&magnitude, 0.0F, 1.0F);
    uint16_t magint = (uint16_t)(magangle * (float)LUT_LENGTH);
    _aStep = magint; // a phase just right on this thing, 
    // lut_length / 4 = lut_length >> 2 (rotates phase 90 degs)
    // x modulo y = (x & (y âˆ’ 1))       (wraps phase around end of lut)
    _bStep = (magint + ((uint16_t)LUT_LENGTH >> 2)) & (LUT_LENGTH - 1);
    // upd8 the cscale 
    _cscale = magnitude;
    // now we should be able to... 
    writePhases(); 
}

// sequence like
// S: 1 2 3 4 5 6 7 8 
// A: ^ ^ ^ x v v v x
// B: ^ x v v v x ^ ^
void STEP_A4950::step(uint16_t microticks){
    // increment 
    if(_dir && !_dir_invert){
        _aStep += microticks;
        if(_aStep > LUT_LENGTH) _aStep -= LUT_LENGTH;
        _bStep += microticks;
        if(_bStep > LUT_LENGTH) _bStep -= LUT_LENGTH;
    } else {
        if(_aStep - microticks < 0) _aStep += LUT_LENGTH;
        _aStep -= microticks;
        if(_bStep - microticks < 0) _bStep += LUT_LENGTH;
        _bStep -= microticks;
    }
    // hw writes 
    writePhases();
}

void STEP_A4950::dir(boolean val){
    _dir = val;
}

boolean STEP_A4950::getDir(void){
    return _dir;
}

void STEP_A4950::setCurrent(float cscale){
    if(cscale > 1){
        _cscale = 1;
    } else if(cscale < 0){
        _cscale = 0;
    } else {
        _cscale = cscale;
    }
    // do DAC re-writes 
    dacs->writeDac0(dacLUT[_aStep] * _cscale);
    dacs->writeDac1(dacLUT[_bStep] * _cscale);
}

void STEP_A4950::dacRefresh(void){
    dacs->refresh();
}
